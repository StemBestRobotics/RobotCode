#pragma config(Motor,  port4,           funnelServo,   tmotorServoStandard, openLoop)
#pragma config(Motor,  port5,           leftMotor,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           rightMotor,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           armMotor,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           digitalMotor,  tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           clawServo,     tmotorServoStandard, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
This program is meant drive with arcade control
Compiled 9/17/16 by STEMATOES
*/

//Function that controls Arcade Drive
void arcadeDrive(){
  int joy_x;            // will hold the X value of the analog stick (choices below)
  int joy_y;            // will hold the Y value of the analog stick (choices below)
  int threshold = 10;

	joy_x = vexRT[Ch4];   // This is the RIGHT analog stick.  For LEFT, change 'Ch1' to 'Ch4'.
    joy_y = vexRT[Ch3];   // This is the RIGHT analog stick.  For LEFT, change 'Ch2' to 'Ch3'.

    // Forward, and swing turns: (both abs(X) and abs(Y) are above the threshold, and Y is POSITIVE)
    if(((abs(joy_x) > threshold) || (abs(joy_y) > threshold)) && (joy_y < 0))
    {
      motor[leftMotor]  = (joy_y + joy_x)/2;
      motor[rightMotor] = (joy_y - joy_x)/2;
    }
    // Backwards and swing turns: (both abs(X) and abs(Y) are above the threshold, and Y is NEGATIVE)
    else if(((abs(joy_x) > threshold) || (abs(joy_y) > threshold)) && (joy_y > 0))
    {
      motor[leftMotor]  = (joy_y - joy_x)/2;
      motor[rightMotor] = (joy_y + joy_x)/2;
    }
    // Turning in place: (abs(X) is above the threshold, abs(Y) is below the threshold)
    else if((abs(joy_x) > threshold) && (abs(joy_y) < threshold))
    {
      motor[leftMotor]  = joy_x;
      motor[rightMotor] = (-1 * joy_x);
    }
    // Standing still: (both abs(X) and abs(Y) are below the threshold)
    else
    {
      motor[leftMotor]  = 0;
      motor[rightMotor] = 0;
    }
}

void digitalMotorControl(){
	int btn1 = vexRT(Btn8L);
	if(btn1 == 1){
		motor[port8] = 63;
	}else{
		motor[port8] = 0;
	}
}

void armMotorControl(){

//Declare and Initialize Ch2 as Vex Controller channel 2, which
//We can change joystick controls depending on what the driver wants
int c2 = vexRT[Ch2];
	if(c2<-10||c2>10){
		motor[port7] = Ch2;
	}else{
		motor[c2] = 0;
	}
}

void clawServoControl(){
	int btn2 = vexRT(Btn6U);
	int btn3 = vexRT(Btn6D);
	if(btn2 == 1){
		motor[port9] = 131;
	}
	if(btn3 == 1){
		motor[port9] = 0;
	}
}

void funnelServoControl(){
	int btn4 = vexRT(Btn5U);
	int btn5 = vexRT(Btn5D);
	if(btn4 == 1){
		motor[port4] = 131;
	}
	if(btn5 == 1){
		motor[port4] = -55;
	}
}

//Main body of program
task main{
	//Drive Arcade
	while(1==1){
	arcadeDrive();
	digitalMotorControl();
	armMotorControl();
	clawServoControl();
	funnelServoControl();
	} //loop end
}
