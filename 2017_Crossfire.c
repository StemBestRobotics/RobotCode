#pragma config(Motor,  port2,           motorLeft,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           shootingMotor, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           scoopMotor,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           motorRight,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           waterControlServo,    tmotorServoStandard, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
Requirements:
A basic arcade movement drive that can be switched to a tank control function that can accommodate our driversâ?? needs as to increase ease of use with the drivers and therefore increase the score, through ease of driver use.

The arcade movement takes one joystick as input, or two channels, and sets the motor values if it is within a small range of tolerance it sets it definitively (To account for design imperfection in the controller and for slight drifting due to imperfect joystick position). These "Tolerance ranges" are a range of 30 and they are around the controls of turning movement and directional movement

The tank movement takes two joystick inputs and uses their "Heights" as inputs to the movement motors

*/
bool arcadeControlMethod = false;//This is switched based on driver preference, to provide advanced control
int tolerance = 30;
bool centrifugalOn = false;
bool centreCheck = false;
bool arcadeCheck = false;
bool orderCheck = false;
bool servoSwap = false;
bool actServoCheck = false;
bool actServoOn = false;
/*
Some drivers like tank based control (Each joysticks outputs to the motor) and some like arcade (Generic control method where one joystick controls all movement), this can be easily switched here as such to accommodate the specific driver's needs
*/
void arcadeDrive(){	//Function for arcade drive
	//If the joystick is in a small range from the center in both directions, the robot should be stopped
	if( abs( vexRT[Ch1] ) < tolerance && abs ( vexRT[Ch2] ) < tolerance){
		motor[motorLeft] = 0;
		motor[motorRight] = 0;
	//If the joystick is in a small vertical range, for moving forward/backward
	}else if( abs( vexRT[Ch1] ) < tolerance ){
		motor[motorLeft] = vexRT[Ch2];
		motor[motorRight] = vexRT[Ch2]*-1;
	//If the joystick is in a small horizontal range, the robot will turn left or right
	}else if( abs( vexRT[Ch2] ) < tolerance ){
		motor[motorLeft] = vexRT[Ch1];
		motor[motorRight] = vexRT[Ch1];
	//If the joystick is forward, do a forward swing turn
	}else if( vexRT[Ch2] > tolerance ){
		//As the horizontal channel becomes more positive, the robot turns to the right.
		//As the horizontal channel becomes more negative, the robot turns to the left.
		//Thinking of these averages as a graph, with the horizontal channel as the input,
		//and motor output as the output, the left motor would become much higher positive number as the input becomes positive, and the right motor
		//would become a much smaller positive number as the input becomes negative.
		motor[motorLeft] = ((vexRT[Ch2]+vexRT[Ch1]))/2;
		motor[motorRight] = ((vexRT[Ch2]-vexRT[Ch1]))/-2;
	//If the joystick is negative, do a backward swing turn
	}else if( vexRT[Ch2] < -tolerance ){
		//As the horizontal channel becomes more positive, the robot turns to the left.
		//As the horizontal channel becomes more negative, the robot turns to the right.
		//Thinking of these averages as a graph, with the horizontal channel as the input,
		//and motor output as the output, the left motor would become much higher positive number as the input becomes negative, and the right motor
		//would become a much smaller positive number as the input becomes positive.
		motor[motorLeft] = ((vexRT[Ch2]+vexRT[Ch1]))/2;
		motor[motorRight] = ((vexRT[Ch2]-vexRT[Ch1]))/-2;
	}
}
//2 Joystick tank control
void tankMovement(){
	//Dead zone to correct for faulty joysticks.
	if(abs(vexRT(Ch2))<=10 && abs(vexRT(Ch3))<=10){
	motor[motorRight]=0;
	motor[motorLeft]=0;
	}else{
	//Left Joystick up/down is the left motors power
	motor[motorLeft] = vexRT[Ch3];
	//Right joystick up/down is the right motors power
	motor[motorRight] = vexRT[Ch2] * -1;
	}
}
void toggleArcade(){
	//Toggle switch. Btn7U is pressed, operating value inverts. Changes between arcade and tank drive.
	if((vexRT[Btn7U]==1)&&(arcadeCheck==false)){
			arcadeControlMethod=!arcadeControlMethod;
			arcadeCheck = true;
		}
		if((vexRT[Btn7U]==false)&&(arcadeCheck==true)){
			arcadeCheck = false;
		}
}
void drive(){
	//Toggle switch. Btn7U is pressed, operating value inverts. Changes between arcade and tank drive.
	toggleArcade();
	//Tank if driver chooses tank, arcade if driver chooses that.
	if(arcadeControlMethod==true){
		arcadeDrive();
	}else{
		tankMovement();
	}
}

void orderWater(){
	if((vexRT[Btn7L]==true)&&(actServoCheck==false)){
		actServoOn = !actServoOn;
		actServoCheck=true;
	}
	if((vexRT[Btn7L]==false)&&(actServoCheck==true)){
		actServoCHeck = false;
	}
	if(actServoOn==true){
		if((time100[T1]%5==true)&&(orderCheck==false)){//This is a switch that allows the code to switch between arcade controll on a button
			servoSwap=!servoSwap;
			orderCheck = true;
		}
		if((time100[T1]%5==false)&&(orderCheck==true)){
			orderCheck = false;
		}
		if(servoSwap == true){
			motor(waterControlServo) = 127;
			}else if(servoSwap == false){
			motor(waterControlServo) = -127;
		}
	}
}

void shoot(){
	orderWater();
	if((vexRT[Btn5U]==1)&&(centreCheck==false)){//This is a switch to change if the shooting motor is on, so the drivers don't have to hold down the button
		centrifugalOn= (!centrifugalOn);
		centreCheck = true;
	}
	if((vexRT[Btn5U]==false)&&(centreCheck==true)){
		centreCheck = false;
	}
	if(centrifugalOn==true){
		motor[shootingMotor] = 127;
	}else{
		motor[shootingMotor] = 0;
	}
}

void rescue(){

	//Turns scoopMotor clockwise if button 5U is pressed
	if (vexRT[Btn6U]) {
		motor[scoopMotor] = 127;
	}

	//Turns scoopMotor counterclockwise if button 5D is pressed
	else if (vexRT[Btn6D]) {
		motor[scoopMotor] = -127;
	}

	//Stops scoopMotor if buttons 5U and 5D aren't being pressed
	else {
		motor[scoopMotor] = 0;
	}
}

//Task main is the beginning of the program
task main()
{
	//Infinite loop causes infinite execution
	while(1==1){
		//function that controls driving
		drive();
		shoot();
		rescue();
	}
}
