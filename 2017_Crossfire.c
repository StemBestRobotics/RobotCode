#pragma config(Motor,  port2,           motorLeft,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           motorRight,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           shootingMotor, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           shootingServo, tmotorServoStandard, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
Requirements:
A basic arcade movement drive that can be switched to a tank controll function that can accomidate our
drivers needs as to increase ease of use with the drivers and therfor increase the score

the arcade movement takes one joystick inputs and sets the motor values, if it is within
a small range of tolerence it sets it definitively(To account for design inperfection in the controller
and for slight drifing due to imperfect joystick position) These "Tolerence ranges" are a range of 90 and
they are around the contolls of turning movement and directional movement

The tank movement takes two joystick inputs and uses their "Hights" as inputs to the movement motors

There is also a gearshift that must half the speed of the motor when pressed. It would work as a toggle that could also
shift back, this is in place to allow drivers to have fast movement and fine tuned persision

the different movement options(2 joystick tank controll and 1 joystick arcade controll) must both be switched with
a toggle, akin to the gearshifts toggle, that can freely switch between the controll systems, making it easier on the drivers
thus makes the aplication of out scoring stratigies signifigantly easier

There must also be a servo which moves to max on a button, and moves to start on a different button to operate the shooting arm
In combonation there must be a motor that turns one way when a button is pressed, turn the other way when a different button is pressed, and turn of If
neither are pressed
*/
float speedScaler = 1;//This value is multiplied by the speed as to allow for fine controll over the robot if set less than
bool arcadeControlMethod = false;
/*
some drivers like tank based controll(Each joysticks outputs to the motor)
and arcade(Generic controll method one joystick controlls all movement),
this can be easily switched here as such to accomadate the drivers needs
*/
int tolerance = 30;
/*
A small range of tolerence it sets to allow for definitively outputs(To account for design inperfection in the controller
and for slight drifing due to imperfect joystick position) These "Tolerence ranges" are set here and
they are around the contolls of turning movement and directional movement(where drifting occurs frequently)
*/
void arcadeMovement(){	//Function for joystick based input controll
	if( abs( vexRT[Ch1] ) < tolerance && abs ( vexRT[Ch2] ) < tolerance){//If the joystick is in a small range of the center in both directions, when the robot should be stopped
		motor[motorLeft] = 0;//Dead zone, if it near the center it should be fully off, however because of slight imperfections it is still slighly moving, wasting battery
		motor[motorRight] = 0;
	}else if( abs( vexRT[Ch1] ) < tolerance ){//If the joystick is in a small range of the center verticly IE moving forward/backward
		motor[motorLeft] = vexRT[Ch2]* speedScaler;//The speedScaler is to apply the speed controll The speed controll exists to allow the drivers to switch from rapid movement to fine controll
		motor[motorRight] = vexRT[Ch2]*-1* speedScaler;//The speedScaler is to apply the speed controll The speed controll exists to allow the drivers to switch from rapid movement to fine controll
	}else if( abs( vexRT[Ch2] ) < tolerance ){//If the joystick is in a small range of the center horisontaly IE turning Left/right
		motor[motorLeft] = vexRT[Ch1]* speedScaler;//The speedScaler is to apply the speed controll The speed controll exists to allow the drivers to switch from rapid movement to fine controll
		motor[motorRight] = vexRT[Ch1]* speedScaler;//The speedScaler is to apply the speed controll The speed controll exists to allow the drivers to switch from rapid movement to fine controll
	}else if( vexRT[Ch2] > tolerance ){//If the joystick is forward, doing a forward swing turn
		motor[motorLeft] = ((vexRT[Ch2]+vexRT[Ch1])* speedScaler)/2;//If it moves closer to the top the subtraction is less relevent
		//The speedScaler is to apply the speed controll The speed controll exists to allow the drivers to switch from rapid movement to fine controll
		motor[motorRight] = ((vexRT[Ch2]-vexRT[Ch1])* speedScaler)/-2;//The subtraction is flipped because the motors should be switched
		//The speedScaler is to apply the speed controll The speed controll exists to allow the drivers to switch from rapid movement to fine controll
	}else if( vexRT[Ch2] < -tolerance ){//If the joystick is backward, doing a backward swing turn
		motor[motorLeft] = ((vexRT[Ch2]+vexRT[Ch1])* speedScaler)/2;//Same as above, but because it is in the bottom thresehold, it should be inverted, so the subtraction is flipped
		//The speedScaler is to apply the speed controll The speed controll exists to allow the drivers to switch from rapid movement to fine controll
		motor[motorRight] = ((vexRT[Ch2]-vexRT[Ch1])* speedScaler)/-2;
		//The speedScaler is to apply the speed controll The speed controll exists to allow the drivers to switch from rapid movement to fine controll
	}
}
void tankMovement(){//2 Joystick tank controlls
	if(abs(vexRT(Ch2))<=10 && abs(vexRT(Ch3))<=10){
	motor[motorRight]=0;
	motor[motorLeft]=0;
	}else{
	motor[motorLeft] = vexRT[Ch3] * speedScaler;//Left Joystick up/down is the left motors power
	//The speedScaler is to apply the speed controll The speed controll exists to allow the drivers to switch from rapid movement to fine controll
	motor[motorRight] = vexRT[Ch2] * -1 * speedScaler;//Right joystick up/down is the right motors power
	//The speedScaler is to apply the speed controll The speed controll exists to allow the drivers to switch from rapid movement to fine controll
	}
}
void shootingMotorFunction() {
		//Rotates motor 127 degrees clockwise if button 8L is pressed
		if (vexRT[Btn8L]){
			motor(shootingMotor) = 127;
		}

		//Rotates motor 127 degrees counterclockwise if button 8R is pressed
		else if (vexRT[Btn8R]){
			motor(shootingMotor) = -127;
		}

		//Stops motor rotation if buttons 8R or 8L aren't being pressed
		else {
				motor(shootingMotor) = 0;
		}
}
void shootingServoFunction() {
	//Rotates servo 127 degrees clockwise if button 7L is pressed
	if (vexRT[Btn7L]){
		motor(shootingServo) = 127;
	}

	//Rotates servo 127 degrees counterclockwise if button 7R is pressed
	else if (vexRT[Btn7R]){
		motor(shootingServo) = -127;
	}
}
task main()//Runs at start of program
{
	bool speedCheck = false;
	bool arcadeCheck = false;
	while(1==1){//Forever, this is the code that keeps the bot running throughout the compitition
		if((vexRT[Btn7U]==1)&&(arcadeCheck==false)){//This is a switch that allows the code to switch between arcade controll on a button
			arcadeControlMethod=!arcadeControlMethod;
			arcadeCheck = true;
		}
		if((vexRT[Btn7U]==false)&&(arcadeCheck==true)){
			arcadeCheck = false;
		}

		if((vexRT[Btn8U]==1)&&(speedCheck==false)){//This is a switch that allows the code to switch the gear on a button
			if(speedScaler==1){
				speedScaler=0.5;//This sets the speedcontroller to half
			}else{
				speedScaler=1;//This sets the speedcontroller to full
			}
			speedCheck = !speedCheck;
		}
		if((vexRT[Btn8U]==false)&&(speedCheck==true)){
			speedCheck = false;
		}
		if(arcadeControlMethod==true){//Tests if the driver wants arcade or tank based controlls, each rewrites the inputs
			arcadeMovement();//Runs a test of arcade based movement(Changing the motors based on arcade controll mapping)
		}else{
			tankMovement();//Runs a test for tank based controll mapping(Changing the motors based on the 2 joysticks "Hight"(I am using hight to represent their upwards value)
		}
		if (vexRT[Btn8L]){
			motor(shootingMotor) = 127;
		}
	}
}
