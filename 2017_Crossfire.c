#pragma config(Sensor, dgtl11, limitUp,        sensorTouch)
#pragma config(Sensor, dgtl12, limitDown,      sensorTouch)
#pragma config(Motor,  port2,           motorLeft,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           shootingMotor, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           aimingServo,   tmotorServoStandard, openLoop)
#pragma config(Motor,  port5,           waterControlServo, tmotorServoStandard, openLoop)
#pragma config(Motor,  port6,           mannyMagServoOne, tmotorServoStandard, openLoop)
#pragma config(Motor,  port7,           mannyMagServoTwo, tmotorServoStandard, openLoop)
#pragma config(Motor,  port8,           scoopMotor,    tmotorVex393_MC29, openLoop)
#pragma config(Motor, port9, motorRight, tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
Requirements:
Robot must drive. Performed by drive function.
The driving function must provide both tank and arcade control. It does.
The robot must rescue Manny. Provided by the rescue function.
The robot must not move the rescue device past a certain limit. It meets this requirement.
The robot must shoot water. Provided by the shoot function.
The robot must sort the water into an ordered pattern. The robot does.

UI:
6U: lift manny rescue device
6D: put down manny rescue device
5U: Toggle shooter.

7L: toggle ball organizer.
7U: toggle arcade drive or tank drive.

*/
bool arcadeControlMethod = false; //This is switched based on driver preference, to provide advanced control
int tolerance = 30; //deadzone to correct for faulty joysticks
bool centrifugalOn = false; //toggle boolean for shooter
bool centreCheck = false; //check boolean for shooter
bool arcadeCheck = false; //check boolean for drive toggle
bool orderCheck = false; //check boolean for water organizer
bool servoSwap = false; //toggle boolean for water organizer
bool actServoCheck = false; //check boolean for water automated movement
bool actServoOn = false; //toggle boolean for water automated movement
bool mannyMagnetCheck = false;//Check boolean for mannymagnet toggle
bool mannyMagnetOn=false;//This Controls the magnet on the servo
bool aimServoCheck = false;//Check boolean for aimservo toggle
bool aimServoOn=false;//This Controls the aiming servo
/*
Some drivers like tank based control (Each joysticks outputs to the motor) and some like arcade (Generic control method where one joystick controls all movement), this can be easily switched here as such to accommodate the specific driver's needs
*/
void arcadeDrive(){	//Function for arcade drive
	//If the joystick is in a small range from the center in both directions, the robot should be stopped
	if( abs( vexRT[Ch1] ) < tolerance && abs ( vexRT[Ch2] ) < tolerance){
		motor[motorLeft] = 0;
		
		motor[motorRight] = 0;
		//If the joystick is in a small vertical range, for moving forward/backward
		}else if( abs( vexRT[Ch1] ) < tolerance ){
		motor[motorLeft] = vexRT[Ch2];
		motor[motorRight] = vexRT[Ch2]*-1;
		//If the joystick is in a small horizontal range, the robot will turn left or right
		}else if( abs( vexRT[Ch2] ) < tolerance ){
		motor[motorLeft] = vexRT[Ch1];
		motor[motorRight] = vexRT[Ch1];
		//If the joystick is forward, do a forward swing turn
		}else if( vexRT[Ch2] > tolerance ){
		//As the horizontal channel becomes more positive, the robot turns to the right.
		//As the horizontal channel becomes more negative, the robot turns to the left.
		//Thinking of these averages as a graph, with the horizontal channel as the input,
		//and motor output as the output, the left motor would become much higher positive number as the input becomes positive, and the right motor
		//would become a much smaller positive number as the input becomes negative.
		motor[motorLeft] = ((vexRT[Ch2]+vexRT[Ch1]))/2;
		motor[motorRight] = ((vexRT[Ch2]-vexRT[Ch1]))/-2;
		//If the joystick is negative, do a backward swing turn
		}else if( vexRT[Ch2] < -tolerance ){
		//As the horizontal channel becomes more positive, the robot turns to the left.
		//As the horizontal channel becomes more negative, the robot turns to the right.
		//Thinking of these averages as a graph, with the horizontal channel as the input,
		//and motor output as the output, the left motor would become much higher positive number as the input becomes negative, and the right motor
		//would become a much smaller positive number as the input becomes positive.
		motor[motorLeft] = ((vexRT[Ch2]+vexRT[Ch1]))/2;
		motor[motorRight] = ((vexRT[Ch2]-vexRT[Ch1]))/-2;
	}
}
//2 Joystick tank control
void tankMovement(){
	//Dead zone to correct for faulty joysticks.
	if(abs(vexRT(Ch2))<=10 && abs(vexRT(Ch3))<=10){
		motor[motorRight]=0;
		motor[motorLeft]=0;
		}else{
		//Left Joystick up/down is the left motors power
		motor[motorLeft] = vexRT[Ch3];
		//Right joystick up/down is the right motors power
		motor[motorRight] = vexRT[Ch2] * -1;
	}
}
void toggleArcade(){
	//Toggle switch. Btn7U is pressed, operating value inverts. Changes between arcade and tank drive.
	if((vexRT[Btn7U]==1)&&(arcadeCheck==false)){
		arcadeControlMethod=!arcadeControlMethod;
		arcadeCheck = true;
	}
	if((vexRT[Btn7U]==false)&&(arcadeCheck==true)){
		arcadeCheck = false;
	}
}
void drive(){
	//Toggle switch. Btn7U is pressed, operating value inverts. Changes between arcade and tank drive.
	toggleArcade();
	if(arcadeControlMethod==true){
		arcadeDrive();
		}else{
		tankMovement();
	}
}

void orderWater(){
	//toggle actServoCheck to enable or disable water organization.
	if((vexRT[Btn7L]==true)&&(actServoCheck==false)){
		actServoOn = !actServoOn;
		actServoCheck=true;
	}
	if((vexRT[Btn7L]==false)&&(actServoCheck==true)){
		actServoCheck = false;
	}
	//move servo every 500ms.
	if(actServoOn==true){
		if((time100[T1]%5==true)&&(orderCheck==false)){
			servoSwap=!servoSwap;
			orderCheck = true;
		}
		if((time100[T1]%5==false)&&(orderCheck==true)){
			orderCheck = false;
		}
		if(servoSwap == true){
			motor(waterControlServo) = 127;
			}else if(servoSwap == false){
			motor(waterControlServo) = -127;
		}
	}
}

void aimServo(){
	//This is a servo that will go up and down on a toggle.
	if((vexRT[Btn7R]==true)&&(aimServoCheck==false)){
		aimServoOn = !aimServoOn;
		aimServoCheck=true;
	}
	if((vexRT[Btn7R]==false)&&(aimServoCheck==true)){
		aimServoCheck = false;
	}
	if(aimServoCheck){//If the manny magnet is activated
		motor[aimingServo]=90;//set the servo's to 90 degrees
	}else{
		motor[aimingServo]=0;//set the servo's to 0 degrees
	}
}

//shoot water
void shoot(){
	//break up patterns in balls
	orderWater();
	//aim
	aimServo();
	//toggle launcher
	if((vexRT[Btn5U]==1)&&(centreCheck==false)){//This is a switch to change if the shooting motor is on, so the drivers don't have to hold down the button
		centrifugalOn= (!centrifugalOn);
		centreCheck = true;
	}
	if((vexRT[Btn5U]==false)&&(centreCheck==true)){
		centreCheck = false;
	}
	if(centrifugalOn==true){
		motor[shootingMotor] = 127;
		}else{
		motor[shootingMotor] = 0;
	}
}

void mannyMagnet(){
	//This is a servo that will go up and down on a toggle.
	if((vexRT[Btn5D]==true)&&(mannyMagnetCheck==false)){
		mannyMagnetOn = !mannyMagnetOn;
		mannyMagnetCheck=true;
	}
	if((vexRT[Btn5D]==false)&&(mannyMagnetCheck==true)){
		mannyMagnetCheck = false;
	}
	if(mannyMagnetOn){//If the manny magnet is activated
		motor[mannyMagServoOne]=90;
		motor[mannyMagServoTwo]=90;//set the servo's to 90 degrees
	}else{
		motor[mannyMagServoOne]=0;
		motor[mannyMagServoTwo]=0;//set the servo's to 0 degrees
	}
}

void rescue(){

	mannyMagnet();

	//Turns scoopMotor clockwise if button 5U is pressed
	if (vexRT[Btn6U]&&(SensorValue(limitUp)==true)) {
		motor[scoopMotor] = 127;
	}

	//Turns scoopMotor counterclockwise if button 5D is pressed
	else if (vexRT[Btn6D]&&(SensorValue(limitDown)==true)) {
		motor[scoopMotor] = -127;
	}

	//Stops scoopMotor if buttons 5U and 5D aren't being pressed
	else {
		motor[scoopMotor] = 0;
	}
}

//Task main is the beginning of the program
task main()
{
	//Infinite loop causes infinite execution
	while(1==1){
		drive();
		shoot();
		rescue();
	}
}
