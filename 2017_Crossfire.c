#pragma config(Motor,  port1,           motorLeft,     tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           motorRight,    tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
Requirements:
A basic arcade function, it takes one joystick inputs and sets the motor values


*/
void arcadeMovement(){	//Function for joystick based input controll
		if( abs( vexRT[Ch1] ) < 10 && abs ( vexRT[Ch2] ) < 10){//If the joystick is in a small range of the center
			motor[motorLeft] = 0;
			motor[motorRight] = 0;
		}else if( abs( vexRT[Ch1] ) < 10 ){//If the joystick is in a small range of the center verticly IE moving forward/backward
			motor[motorLeft] = vexRT[Ch2];
			motor[motorRight] = vexRT[Ch2]*-1;
		}else if( abs( vexRT[Ch2] ) < 10 ){//If the joystick is in a small range of the center horisontaly IE moving forward/backward
			motor[motorLeft] = vexRT[Ch1];
			motor[motorRight] = vexRT[Ch1];
		}else if( vexRT[Ch2] > 10 ){
			motor[motorLeft] = (vexRT[Ch2]+vexRT[Ch1])/2;//If it moves closer to the top the subtraction is less relevent
			motor[motorRight] = (vexRT[Ch2]-vexRT[Ch1])/2;//The subtraction is flipped because the motors should be switched
		}else if( vexRT[Ch2] < -10 ){
			motor[motorLeft] = (vexRT[Ch2]-vexRT[Ch1])/2;//Same as above, but because it is in the bottom thresehold, it should be inverted
			motor[motorRight] = (vexRT[Ch2]+vexRT[Ch1])/2;
		}
	}
task main()
{
	while(1==1){
		arcadeMovement();
	}
}
